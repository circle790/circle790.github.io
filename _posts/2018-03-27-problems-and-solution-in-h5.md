---
layout: post
#标题配置
title:  "移动端常规业务总结"
#时间配置
date:   2018-03-27 11:26:00 +0800
categories: Solutions
tag: Mobile
---

* content
{:toc}

引言
------------------------

移动互联网浪潮来袭，使得无论是传统行业还是新兴行业都蜂拥走进用户的手机，一个功能丰富的移动 App 再提供一个便于手机浏览的 Web 页面成为标配，不仅构建了丰富的来源，而且web访问的广泛性使得用户更易获取到产品信息。

关于微信分享卡片
------------------------

自定义微信分享卡片需要接入微信JSSDK，访问[微信JS-SDK说明文档](https://mp.weixin.qq.com/wiki?t=resource/res_main&id=mp1421141115)，通过使用微信JS-SDK，网页开发者可借助微信高效地使用拍照、选图、语音、位置等手机系统的能力，同时可以直接使用微信分享、扫一扫、卡券、支付等微信特有的能力，为微信用户提供更优质的网页体验。如果仅仅只是想设置分享卡片内容，不妨试试这种方式。

- 默认获取页面中title内容作为分享卡片标题
- 默认获取页面中第一张格式大于300*300像素（据说是阅读源码发现）的图片作为分享卡片右侧图标
- 描述内容为当前分享页面地址

![wechat_share]({{ '/styles/images/share.png' | prepend: site.baseurl  }})

需要注意的是，H5的使用场景不仅仅局限于微信，还包括各种类型的浏览器，分享操作的流程各不相同，我们知道微信的分享按钮在标题右上角的三个圆点，而其他的浏览器则没有那么一致了，有的在标题右上角，有的在标题左上角，更多的是显示在底部工具栏菜单里面，所在位置也不确定，提出这样的需求的时候，一定要在前期告知需求方并沟通好分享操作流程的提示形式。对于分享出现的卡片样式，各浏览器形态各异，好在内容总体相同，主要是标题，图标和描述，标题取自页面的title标签触发分享前动态设置没有问题，图标在微信是取页面中首张格式大于300*300像素的图片，而QQ浏览器则是取页面的部分截图，其他浏览器不得而知，描述内容有显示分享页面地址的也有的与标题一致添加了类似'我正在看'前缀和'@XX浏览器'后缀，分享到朋友圈则不显示描述文字，只显示标题文字和图标，可以坑定的是没有特定场景的时候在分享卡片上大作文章无异于徒劳。

除此之外，可能我们还有这样一种分享需求，指定分享页面的地址，做惯hybridApp内嵌webView形式的FE来说随口就答应了，因为我们调用客户端封装的交互能力可以方便的指定一个分享的页面地址，丝毫没有拒绝的理由，直到实现的过程中才会发现原来无论是微信还是其他浏览器分享出去的页面地址就是当前访问地址，不存在指定分享地址的API（即使微信也需要接入微信JSSDK），那有什么权益之策么，恩，是有的，回顾一下移动端浏览器分享整个流程，为了引导用户进行分享，在所有的浏览器进行分享都会进行一个分享引导，形式由自己指定，或半透明或白底或许全屏或许局部，就看默契程度了，具体做法就是在弹出引导时我们在用户毫无感知的情况下将后面的页面切换至分享目标地址页面，这样分享出去的页面地址就是目标地址了，当然考虑到用户放弃分享操作关闭引导，我们需要在关闭引导之前将页面切换回之前的页面。到这里远远没有结束，我们进行一下分享测试，可能发现分享的地址并不是目标地址而是进入时的页面地址，取决于切换页面的方式，使用vue-router进行管理路由，微信浏览器是不接受的。`history`模式下也许不存在这种问题（因为此模式涉及到服务端，基于项目没有做过多尝试），我使用的是hash模式，调用导航方法（`push`、`replace`、`go`）对访问记录进行堆栈处理，坑点就是，href的解释vue-router与规范是不相符合的，hash模式使用哈希值变化记录路由决定动态插入页面内容，query参数是放在哈希值后面，规范的解释是hash是放在地址最后，search参数在前面，回到问题中来，如此切换页面时微信在地址上拼接了几个参数`from=singlemessage` `appinstall=0`等，然而拼接却没有进行严格的逻辑处理（QQ就是直接在路径后添加了一个'&appinstall=0'），涉及服务端根据url获取fragment可能出错，甚至页面无法访问。此处页面虽然切换但是地址却没有改变，没有办法放弃使用vue-router使用原生的`location`切换页面总是接受的，却失去了vuex进行统一状态管理的能力，倘若项目足够复杂需要一定的权衡。当然考虑到此处页面切换非常规逻辑，我们可以设置导航守卫进行判断使用原生`location`切换。

```javascript
// 使用hash模式路由，存在search参数时添加参时没有问题
// 在微信、QQ、微博浏览器中路由进入前添加search参数，防止浏览器添加时路由出错
router.beforeEach(function(to, from, next) {
    if((browser.wexin || browser.qq || browser.weibo) && location.search === '') {
        location.replace(location.origin + location.pathname + '?special_mark=test#' + to.fullPath)
    } else {
        next()
    }
})
```

唤醒APP页面和引导下载
------------------------

唤醒和引导下载是web端很频繁的业务需求，推广活动中吸引用户注册再下载APP领取或者使用奖励是很普遍的运营技巧，也有涉及接口权限需要点击进入APP内进行活动体验的情况。归纳起来首先判断用户设备是否安装APP应用，安装则打开应用反之则引导下载。通常web页面直接判断设备上是否安装某个应用不太可能，这里假设用户设备已经安装应用采用尝试的方式进行执行，执行成功则成功，失败则进行再处理，重点是采用哪种方式进行尝试。

**自定义 Scheme**
不同于标准的拦截http跳转，自定义scheme兼容绝大多数浏览器。客户端可以通过修改`manifest.xml`文件声明拦截指定的协议，交互方式大致分为如下两种情况：

![hybrid]({{ '/styles/images/hybrid.png' | prepend: site.baseurl  }})

- web页面调用约定API将方法挂载至webview的`window`中，原生根据"协议头://匹配字段"捕获方法并执行
- web页面访问约定的url scheme（协议头://匹配字段），原生监听协议启动应用程序的对应activity，如访问一个原生页面

**Chrome Intent**
Chrome25后不再支持自定义的scheme,推出了Chrome Intent,将scheme统一为'intent'，大量信息放到了锚点'#'之后，作为'fragment'（此fragment非彼fragment），描述uri接收者。

```
    // 打开以whatever协议的URL
    intent://whatever#Intent;package=com.myapp.android;scheme=myapp;end;
```

然而无论使用那种方式都需要客户端资源支持，且不能覆盖全部浏览器，像uc浏览器，微信qq内置浏览器禁止跳转第三平台，除非拥有内置白名单权限。

访问native页面

![get_native]({{ '/styles/images/get_native.png' | prepend: site.baseurl  }})

下载页逻辑

![download_logic]({{ '/styles/images/download_logic.png' | prepend: site.baseurl  }})

部分浏览器在执行自定义scheme协议时进行弹窗提示，图中scheme的响应缓冲时间阈值均设置为600ms，若600ms内用户未进行授权则执行后续操作，也有进行间隔重复尝试的案例，实际效果没有太大区别。

简单的使用`<a>`标签来做这件事情，若手机中未安装客户端，点击后就会跳转到一个错误页面，解决方案很简单，使用动态插入`<iframe>`即可。

最后，自定义scheme在原生与web之间能够实现很多事情，赋予web很多原生的能力，比如约定一些页面跳转，定制header组件，调用native级别UI组件（分享，loading，消息提示等）。合理恰当的交互协议制定无疑带来更好的交互体验。

---------
扩展阅读

[#黑科技# 跳出浏览器](https://zhuanlan.zhihu.com/p/19848910)
[浅谈Hybrid技术的设计与实现](http://www.cnblogs.com/yexiaochai/p/5813248.html)

---------
